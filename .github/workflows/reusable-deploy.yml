name: Reusable Deploy

on:
  workflow_call:
    inputs:
      environment:
        description: "Environment to deploy to (development, production)"
        required: true
        type: string
      aws-region:
        description: "AWS region for deployment"
        required: true
        type: string
      terraform-version:
        description: "Terraform version to use"
        required: true
        type: string
      working-directory:
        description: "Working directory for Terraform"
        required: false
        type: string
        default: "infra"
      frontend-artefact:
        description: "Frontend build artefact name"
        required: false
        type: string
        default: ""
      backend-artefact:
        description: "Backend build artefact name"
        required: false
        type: string
        default: ""
    secrets:
      AWS_ROLE_TO_ASSUME:
        description: "The ARN of the AWS IAM role to assume."
        required: true
    outputs:
      deployment-url:
        description: "URL of the deployed application"
        value: ${{ jobs.deploy.outputs.deployment-url }}
      function-url:
        description: "Lambda function URL"
        value: ${{ jobs.deploy.outputs.function-url }}

jobs:
  validate-infrastructure:
    name: Validate Infrastructure
    runs-on: ubuntu-latest
    timeout-minutes: 15
    defaults:
      run:
        working-directory: ${{ inputs.working-directory }}

    steps:
      # =================================================================
      # âš™ï¸ TERRAFORM SETUP
      # =================================================================
      # The following Terraform setup steps (checkout, setup terraform, cache)
      # are intentionally duplicated in validate-infrastructure, security-scan,
      # and plan-and-cost jobs.
      #
      # WHY: GitHub Actions does not permit calling a reusable workflow
      # from within a step. Common setup logic must therefore be
      # defined explicitly within each job that needs it, rather than
      # being abstracted into a separate, nested reusable workflow.
      # =================================================================
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ inputs.terraform-version }}
          terraform_wrapper: false

      - name: Configure Terraform plugin cache
        run: |
          mkdir -p ~/.terraform.d/plugin-cache
          echo 'plugin_cache_dir = "$HOME/.terraform.d/plugin-cache"' > ~/.terraformrc

      - name: Cache Terraform providers
        uses: actions/cache@v4
        with:
          path: ~/.terraform.d/plugin-cache
          key: ${{ runner.os }}-terraform-v1-${{ inputs.terraform-version }}-${{ hashFiles(format('{0}/.terraform.lock.hcl', inputs.working-directory)) }}
          restore-keys: |
            ${{ runner.os }}-terraform-v1-${{ inputs.terraform-version }}-
            ${{ runner.os }}-terraform-v1-

      - name: Terraform Init
        working-directory: ${{ inputs.working-directory }}
        run: |
          echo "Initialising Terraform..."
          terraform init -backend=false -input=false
          echo "âœ… Terraform initialisation without backend completed"

      # =================================================================
      # ðŸŽ­ DUMMY ARTIFACT CREATION
      # =================================================================
      # This step creates a temporary, empty placeholder file that satisfies
      # Terraform''s filebase64sha256() function calls during validation.
      #
      # WHY: The validate-infrastructure job runs before the real artifacts
      # are downloaded. Terraform validation needs the file to exist for
      # syntax checking, but doesn''t need the actual content at this stage.
      #
      # INDUSTRY STANDARD: This is the recommended approach for CI/CD
      # pipelines where infrastructure validation runs in parallel with or
      # before artifact downloads. It keeps validation fast and decouples
      # infrastructure syntax checks from application build artifacts.
      #
      # ALTERNATIVES CONSIDERED:
      # - Download artifacts in validation job: Slower, couples concerns
      # - Skip validation: Reduces safety, not recommended
      # - Modify Terraform: Breaks local development workflow
      # =================================================================
      - name: Create dummy artifact for validation
        run: |
          echo "Creating dummy artifact for Terraform validation..."
          mkdir -p ../dist
          touch ../dist/score_api.zip
          echo "âœ… Dummy artifact created: ../dist/score_api.zip"

      - name: Terraform Format Check
        run: |
          echo "Checking Terraform formatting..."
          if ! terraform fmt -check -recursive -diff; then
            echo "âŒ Terraform formatting check failed"
            echo "Run 'terraform fmt -recursive' to fix formatting issues"
            exit 1
          else
            echo "âœ… Terraform formatting is correct"
          fi

      - name: Terraform Validate
        run: |
          echo "Validating Terraform configuration..."
          if terraform validate -json > validation-results.json; then
            echo "âœ… Terraform validation passed"
            cat validation-results.json | jq -r '.diagnostics[]? | "[\(.severity | ascii_upcase)] \(.summary): \(.detail)"' || true
          else
            echo "âŒ Terraform validation failed"
            cat validation-results.json | jq -r '.diagnostics[]? | "[\(.severity | ascii_upcase)] \(.summary): \(.detail)"'
            exit 1
          fi

      - name: Upload validation results
        uses: actions/upload-artifact@v4
        with:
          name: terraform-validation-results
          path: ${{ inputs.working-directory }}/validation-results.json
          retention-days: 30

  security-scan:
    name: Infrastructure Security Scan
    runs-on: ubuntu-latest
    timeout-minutes: 10
    defaults:
      run:
        working-directory: ${{ inputs.working-directory }}

    steps:
      # =================================================================
      # âš™ï¸ TERRAFORM SETUP
      # =================================================================
      # The following Terraform setup steps (checkout, setup terraform, cache)
      # are intentionally duplicated in validate-infrastructure, security-scan,
      # and plan-and-cost jobs.
      #
      # WHY: GitHub Actions does not permit calling a reusable workflow
      # from within a step. Common setup logic must therefore be
      # defined explicitly within each job that needs it, rather than
      # being abstracted into a separate, nested reusable workflow.
      # =================================================================
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ inputs.terraform-version }}
          terraform_wrapper: false

      - name: Configure Terraform plugin cache
        run: |
          mkdir -p ~/.terraform.d/plugin-cache
          echo 'plugin_cache_dir = "$HOME/.terraform.d/plugin-cache"' > ~/.terraformrc

      - name: Cache Terraform providers
        uses: actions/cache@v4
        with:
          path: ~/.terraform.d/plugin-cache
          key: ${{ runner.os }}-terraform-v1-${{ inputs.terraform-version }}-${{ hashFiles(format('{0}/.terraform.lock.hcl', inputs.working-directory)) }}
          restore-keys: |
            ${{ runner.os }}-terraform-v1-${{ inputs.terraform-version }}-
            ${{ runner.os }}-terraform-v1-

      - name: Terraform Init
        working-directory: ${{ inputs.working-directory }}
        run: |
          echo "Initialising Terraform..."
          terraform init -backend=false -input=false
          echo "âœ… Terraform initialisation without backend completed"

      - name: Run tfsec security scan
        uses: aquasecurity/tfsec-action@v1.0.0
        with:
          working_directory: ${{ inputs.working-directory }}
          format: json
          soft_fail: true

      - name: Setup Python for Checkov
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install Checkov
        run: |
          pip install checkov

      - name: Run Checkov compliance scan
        run: |
          echo "Running Checkov compliance scan..."
          checkov -d . --framework terraform --output json --output-file checkov-results.json --soft-fail

      - name: Upload security scan results
        uses: actions/upload-artifact@v4
        with:
          name: infrastructure-security-reports
          path: |
            ${{ inputs.working-directory }}/tfsec-results.json
            ${{ inputs.working-directory }}/checkov-results.json
          retention-days: 30

  plan-and-cost:
    name: Terraform Plan & Cost Analysis
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: [validate-infrastructure, security-scan]
    defaults:
      run:
        working-directory: ${{ inputs.working-directory }}

    # OIDC permissions for AWS authentication
    permissions:
      id-token: write
      contents: read
      pull-requests: write

    steps:
      # =================================================================
      # âš™ï¸ TERRAFORM SETUP
      # =================================================================
      # The following Terraform setup steps (checkout, setup terraform, cache)
      # are intentionally duplicated in validate-infrastructure, security-scan,
      # and plan-and-cost jobs.
      #
      # WHY: GitHub Actions does not permit calling a reusable workflow
      # from within a step. Common setup logic must therefore be
      # defined explicitly within each job that needs it, rather than
      # being abstracted into a separate, nested reusable workflow.
      # =================================================================
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ inputs.terraform-version }}
          terraform_wrapper: false

      - name: Configure Terraform plugin cache
        run: |
          mkdir -p ~/.terraform.d/plugin-cache
          echo 'plugin_cache_dir = "$HOME/.terraform.d/plugin-cache"' > ~/.terraformrc

      - name: Cache Terraform providers
        uses: actions/cache@v4
        with:
          path: ~/.terraform.d/plugin-cache
          key: ${{ runner.os }}-terraform-v1-${{ inputs.terraform-version }}-${{ hashFiles(format('{0}/.terraform.lock.hcl', inputs.working-directory)) }}
          restore-keys: |
            ${{ runner.os }}-terraform-v1-${{ inputs.terraform-version }}-
            ${{ runner.os }}-terraform-v1-

      # =================================================================
      # ðŸŽ­ DUMMY ARTIFACT CREATION
      # =================================================================
      # This step creates a temporary, empty placeholder file that satisfies
      # Terraform''s filebase64sha256() function calls during planning.
      #
      # WHY: The plan-and-cost job runs before the real artifacts are
      # downloaded. Terraform plan needs the file to exist for state
      # comparison, but doesn''t need the actual content at this stage.
      #
      # INDUSTRY STANDARD: This is the recommended approach for CI/CD
      # pipelines where infrastructure planning runs in parallel with or
      # before artifact downloads. It keeps planning fast and decouples
      # infrastructure state analysis from application build artifacts.
      #
      # ALTERNATIVES CONSIDERED:
      # - Download artifacts in planning job: Slower, couples concerns
      # - Skip planning: Reduces safety, not recommended
      # - Modify Terraform: Breaks local development workflow
      # =================================================================
      - name: Create dummy artifact for planning
        run: |
          echo "Creating dummy artifact for Terraform planning..."
          mkdir -p ../dist
          touch ../dist/score_api.zip
          echo "âœ… Dummy artifact created: ../dist/score_api.zip"

      - name: Configure AWS credentials using OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          role-session-name: GitHubActions-TerraformPlan
          aws-region: ${{ inputs.aws-region }}
          mask-aws-account-id: false

      # =================================================================
      # ðŸ”§ DYNAMIC BACKEND INITIALIZATION
      # =================================================================
      # Initialise Terraform with environment-specific backend configuration.
      # This ensures each environment (development, production) uses its own
      # isolated state file, preventing state corruption and lock conflicts.
      #
      # The -backend-config flag overrides the generic key in backend.tf with
      # the environment-specific path, ensuring proper state isolation.
      # =================================================================
      - name: Terraform Init
        working-directory: ${{ inputs.working-directory }}
        run: |
          echo "Initialising Terraform for environment: ${{ inputs.environment }}..."
          backend_key="cloud-defenders/envs/${{ inputs.environment }}/terraform.tfstate"
          echo "Using backend key: $backend_key"
          terraform init -input=false -backend-config="key=$backend_key"
          echo "âœ… Terraform initialisation with backend completed"

      - name: Cache Terraform directory
        uses: actions/cache@v4
        with:
          path: ${{ inputs.working-directory }}/.terraform
          key: ${{ runner.os }}-terraform-dir-${{ inputs.terraform-version }}-${{ hashFiles(format('{0}/.terraform.lock.hcl', inputs.working-directory)) }}-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-terraform-dir-${{ inputs.terraform-version }}-${{ hashFiles(format('{0}/.terraform.lock.hcl', inputs.working-directory)) }}-
            ${{ runner.os }}-terraform-dir-${{ inputs.terraform-version }}-

      - name: Generate Terraform plan
        id: plan
        run: |
          echo "Creating Terraform plan..."
          set +e  # Disable immediate exit on error
          terraform plan \
            -input=false \
            -out=tfplan \
            -detailed-exitcode \
            -var="environment=${{ inputs.environment }}" \
            -no-color > plan-output.txt 2>&1

          PLAN_EXIT_CODE=$?
          set -e  # Re-enable immediate exit on error

          if [ $PLAN_EXIT_CODE -eq 0 ]; then
            echo "âœ… No changes detected in Terraform plan"
            echo "plan_status=no-changes" >> $GITHUB_OUTPUT
          elif [ $PLAN_EXIT_CODE -eq 2 ]; then
            echo "âœ… Terraform plan completed with changes"
            echo "plan_status=changes" >> $GITHUB_OUTPUT
          else
            echo "âŒ Terraform plan failed"
            echo "plan_status=failed" >> $GITHUB_OUTPUT
            echo "Error details:"
            cat plan-output.txt
            exit 1
          fi

      - name: Locate Terraform lock file
        if: steps.plan.outputs.plan_status != 'failed'
        id: locate-lock-file
        run: |
          echo "Locating Terraform lock file..."

          # Check in the working directory first (expected location)
          if [ -f "${{ inputs.working-directory }}/.terraform.lock.hcl" ]; then
            echo "âœ… Terraform lock file found in working directory: ${{ inputs.working-directory }}/.terraform.lock.hcl"
            echo "lock_file_path=${{ inputs.working-directory }}/.terraform.lock.hcl" >> $GITHUB_OUTPUT
            ls -la "${{ inputs.working-directory }}/.terraform.lock.hcl"
          # Check in project root (alternative location)
          elif [ -f ".terraform.lock.hcl" ]; then
            echo "âœ… Terraform lock file found in project root: .terraform.lock.hcl"
            echo "lock_file_path=.terraform.lock.hcl" >> $GITHUB_OUTPUT
            ls -la ".terraform.lock.hcl"
          else
            echo "âŒ Terraform lock file not found in either location"
            echo "Checking working directory: ${{ inputs.working-directory }}/"
            ls -la "${{ inputs.working-directory }}/" || true
            echo "Checking project root:"
            ls -la ".terraform.lock.hcl" || true
            exit 1
          fi

      # =================================================================
      # ðŸ“¦ PREPARE ARTIFACTS FOR UPLOAD
      # =================================================================
      # Copy the .terraform.lock.hcl file into the working directory to
      # ensure all files are in a single location for the upload step.
      # This prevents the upload-artifact action from excluding the lock
      # file due to path inconsistencies.
      # =================================================================
      - name: Prepare artifacts for upload
        if: steps.plan.outputs.plan_status != 'failed'
        run: |
          echo "Preparing artifacts for upload..."

          # Copy the lock file to the working directory if it''s in the project root
          if [ -f ".terraform.lock.hcl" ] && [ ! -f "${{ inputs.working-directory }}/.terraform.lock.hcl" ]; then
            echo "Copying .terraform.lock.hcl from project root to working directory..."
            # Ensure the destination directory exists before copying.
            # This is a defensive measure to prevent errors if the directory is missing.
            mkdir -p "${{ inputs.working-directory }}"
            cp .terraform.lock.hcl "${{ inputs.working-directory }}/"
            echo "âœ… Lock file copied to working directory"
          else
            echo "âœ… Lock file already in working directory or not found in root"
          fi

          # Verify all required files are present in the working directory
          echo "Verifying required files in working directory:"
          ls -la "${{ inputs.working-directory }}/" | grep -E "(tfplan|plan-output.txt|.terraform.lock.hcl)" || true

      - name: Generate cost estimate with Infracost
        uses: infracost/actions/comment@v1
        if: steps.plan.outputs.plan_status == 'changes'
        with:
          path: ${{ inputs.working-directory }}/tfplan
          behavior: new
          github-token: ${{ secrets.GITHUB_TOKEN }}

      # =================================================================
      # ðŸ“¦ UPLOAD TERRAFORM PLAN ARTIFACTS
      # =================================================================
      # Upload the Terraform plan and related files for the deploy job.
      # All files are now consolidated in the working directory.
      # =================================================================
      - name: Upload Terraform plan artefacts
        if: steps.plan.outputs.plan_status != 'failed'
        uses: actions/upload-artifact@v4
        with:
          name: terraform-plan-artefacts
          path: ${{ inputs.working-directory }}
          retention-days: 30
          if-no-files-found: error

  deploy:
    name: Deploy Infrastructure & Applications
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: [plan-and-cost]
    if: success()
    environment:
      name: ${{ inputs.environment }}
      url: ${{ steps.deploy-frontend.outputs.deployment-url }}

    # OIDC permissions for AWS authentication
    permissions:
      id-token: write
      contents: read

    outputs:
      deployment-url: ${{ steps.deploy-frontend.outputs.deployment-url }}
      function-url: ${{ steps.deploy-backend.outputs.function-url }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Configure AWS credentials using OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          role-session-name: GitHubActions-Deploy
          aws-region: ${{ inputs.aws-region }}
          mask-aws-account-id: false

      - name: Download build artefacts
        if: inputs.frontend-artefact != '' || inputs.backend-artefact != ''
        uses: actions/download-artifact@v4
        with:
          name: ${{ inputs.frontend-artefact }}
          path: ./frontend-artefact
        continue-on-error: true

      - name: Download backend artefact
        if: inputs.backend-artefact != ''
        uses: actions/download-artifact@v4
        with:
          name: ${{ inputs.backend-artefact }}
          path: ./backend-artefact
        continue-on-error: true

      - name: Download Terraform plan
        uses: actions/download-artifact@v4
        with:
          name: terraform-plan-artefacts
          path: ./terraform-artefacts

      - name: Setup Terraform for infrastructure deployment
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ inputs.terraform-version }}
          terraform_wrapper: false

      - name: Restore Terraform directory cache
        uses: actions/cache@v4
        with:
          path: ${{ inputs.working-directory }}/.terraform
          key: ${{ runner.os }}-terraform-dir-${{ inputs.terraform-version }}-${{ hashFiles(format('{0}/.terraform.lock.hcl', inputs.working-directory)) }}-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-terraform-dir-${{ inputs.terraform-version }}-${{ hashFiles(format('{0}/.terraform.lock.hcl', inputs.working-directory)) }}-
            ${{ runner.os }}-terraform-dir-${{ inputs.terraform-version }}-

      # =================================================================
      # ðŸ”§ DEPLOYMENT EXECUTION
      # =================================================================
      # The deployment job relies on the cached Terraform state from the
      # plan-and-cost job, which already has the correct environment-specific
      # backend configuration. No additional initialisation is needed.
      #
      # The cached .terraform directory contains all necessary provider plugins
      # and the correct backend configuration for the target environment.
      # =================================================================

      # =================================================================
      # ðŸ”§ RESTORE DEPENDENCY LOCK FILE
      # =================================================================
      # Restore the .terraform.lock.hcl file from the plan job to ensure
      # consistency between plan and apply operations. This prevents the
      # "Inconsistent dependency lock file" error by using the exact same
      # provider versions that were used during planning.
      # =================================================================
      - name: Restore Terraform lock file
        working-directory: ${{ inputs.working-directory }}
        run: |
          echo "Restoring Terraform lock file from plan artifacts..."
          if [ -f "../terraform-artefacts/infra/.terraform.lock.hcl" ]; then
            cp ../terraform-artefacts/infra/.terraform.lock.hcl .
            echo "âœ… Terraform lock file restored to working directory"
          else
            echo "âŒ Terraform lock file not found in artifacts"
            echo "Available files in artifacts:"
            ls -la ../terraform-artefacts/ || true
            exit 1
          fi

      - name: Apply Terraform infrastructure changes
        working-directory: ${{ inputs.working-directory }}
        run: |
          echo "Applying Terraform infrastructure changes for ${{ inputs.environment }}..."

          # Copy the plan from artefacts
          cp ../terraform-artefacts/infra/tfplan .

          # Apply the plan (no init needed as cache is restored)
          if terraform apply -input=false tfplan; then
            echo "âœ… Infrastructure deployment completed successfully"
          else
            echo "âŒ Infrastructure deployment failed"
            exit 1
          fi

      - name: Get infrastructure outputs
        id: terraform-outputs
        working-directory: ${{ inputs.working-directory }}
        run: |
          # Get key infrastructure outputs for deployment
          s3_bucket=$(terraform output -raw s3_bucket_name 2>/dev/null || echo "")
          cloudfront_id=$(terraform output -raw cloudfront_distribution_id 2>/dev/null || echo "")
          lambda_function=$(terraform output -raw lambda_function_name 2>/dev/null || echo "")

          echo "s3_bucket=$s3_bucket" >> $GITHUB_OUTPUT
          echo "cloudfront_id=$cloudfront_id" >> $GITHUB_OUTPUT
          echo "lambda_function=$lambda_function" >> $GITHUB_OUTPUT

          echo "Infrastructure outputs retrieved:"
          echo "- S3 Bucket: $s3_bucket"
          echo "- CloudFront Distribution: $cloudfront_id"
          echo "- Lambda Function: $lambda_function"

      - name: Extract frontend artefacts
        if: inputs.frontend-artefact != ''
        run: |
          cd frontend-artefact
          tar -xzf *.tar.gz -C ../frontend/
          echo "Frontend artefacts extracted to frontend/dist/"

      - name: Deploy frontend
        id: deploy-frontend
        if: inputs.frontend-artefact != ''
        uses: ./.github/actions/deploy-frontend
        with:
          aws-region: ${{ inputs.aws-region }}
          s3-bucket: ${{ steps.terraform-outputs.outputs.s3_bucket }}
          cloudfront-distribution-id: ${{ steps.terraform-outputs.outputs.cloudfront_id }}
          environment: ${{ inputs.environment }}
          build-directory: ./frontend/dist
          source-directory: ./frontend

      - name: Deploy backend
        id: deploy-backend
        if: inputs.backend-artefact != ''
        uses: ./.github/actions/deploy-backend
        with:
          aws-region: ${{ inputs.aws-region }}
          function-name: ${{ steps.terraform-outputs.outputs.lambda_function }}
          environment: ${{ inputs.environment }}
          source-directory: ./backend-artefact
          environment-variables: |
            {
              "NODE_ENV": "${{ inputs.environment }}",
              "ENVIRONMENT": "${{ inputs.environment }}",
              "LOG_LEVEL": "${{ inputs.environment == 'production' && 'info' || 'debug' }}"
            }

      - name: Run post-deployment health checks
        run: |
          echo "Running post-deployment health checks for ${{ inputs.environment }} environment..."

          # Use the dedicated health check script
          bash scripts/health-check.sh \
            --frontend-url "${{ steps.deploy-frontend.outputs.deployment-url }}" \
            --backend-url "${{ steps.deploy-backend.outputs.function-url }}" \
            --timeout 30

      - name: Generate deployment summary
        run: |
          echo "## ðŸš€ Deployment Summary for ${{ inputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** ${{ inputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "**Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "### Infrastructure Deployment" >> $GITHUB_STEP_SUMMARY
          echo "âœ… **Terraform Apply:** Completed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ inputs.frontend-artefact }}" != "" ]; then
            echo "### Frontend Deployment" >> $GITHUB_STEP_SUMMARY
            if [ "${{ steps.deploy-frontend.outcome }}" == "success" ]; then
              echo "âœ… **Status:** Successful" >> $GITHUB_STEP_SUMMARY
              echo "ðŸ”— **URL:** ${{ steps.deploy-frontend.outputs.deployment-url }}" >> $GITHUB_STEP_SUMMARY
            else
              echo "âŒ **Status:** Failed" >> $GITHUB_STEP_SUMMARY
            fi
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          if [ "${{ inputs.backend-artefact }}" != "" ]; then
            echo "### Backend Deployment" >> $GITHUB_STEP_SUMMARY
            if [ "${{ steps.deploy-backend.outcome }}" == "success" ]; then
              echo "âœ… **Status:** Successful" >> $GITHUB_STEP_SUMMARY
              echo "ðŸ”— **Function ARN:** ${{ steps.deploy-backend.outputs.function-arn }}" >> $GITHUB_STEP_SUMMARY
              if [ -n "${{ steps.deploy-backend.outputs.function-url }}" ]; then
                echo "ðŸ”— **Function URL:** ${{ steps.deploy-backend.outputs.function-url }}" >> $GITHUB_STEP_SUMMARY
              fi
            else
              echo "âŒ **Status:** Failed" >> $GITHUB_STEP_SUMMARY
            fi
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          echo "Deployment completed successfully! ðŸŽ‰" >> $GITHUB_STEP_SUMMARY
