name: Reusable Build

on:
  workflow_call:
    inputs:
      component:
        description: "Component to build (frontend, backend)"
        required: true
        type: string
      node-version:
        description: "Node.js version to use"
        required: true
        type: string
      working-directory:
        description: "Working directory for the component"
        required: false
        type: string
        default: ""
      build-command:
        description: "Build command to run"
        required: false
        type: string
        default: "build"
      artefact-name:
        description: "Name for the build artefact"
        required: false
        type: string
        default: ""
      environment:
        description: "Environment for the build (development, staging, production)"
        required: false
        type: string
        default: "production"
    outputs:
      build-artefact:
        description: "Build artefact name"
        value: ${{ jobs.build.outputs.build-artefact }}

jobs:
  build:
    name: Build ${{ inputs.component }}
    runs-on: ubuntu-latest
    timeout-minutes: 15
    outputs:
      build-artefact: ${{ steps.build-artefact.outputs.artefact-name }}

    steps:
      # =================================================================
      # âš™ï¸ JOB PREPARATION
      # =================================================================
      # The following preparation steps (checkout, setup node, cache)
      # are intentionally duplicated in both reusable-ci.yml and
      # reusable-build.yml.
      #
      # WHY: GitHub Actions does not permit calling a reusable workflow
      # from within a step. Common setup logic must therefore be
      # defined explicitly within each reusable workflow that needs it,
      # rather than being abstracted into a separate, nested reusable
      # workflow.
      # =================================================================
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ inputs.node-version }}
          cache: "npm"
          cache-dependency-path: ${{ inputs.working-directory }}/package-lock.json

      - name: Restore node_modules cache
        uses: actions/cache@v4
        with:
          path: ${{ inputs.working-directory }}/node_modules
          key: ${{ runner.os }}-node-${{ inputs.node-version }}-${{ inputs.component }}-${{ hashFiles(format('{0}/package-lock.json', inputs.working-directory)) }}
          restore-keys: |
            ${{ runner.os }}-node-${{ inputs.node-version }}-${{ inputs.component }}-
            ${{ runner.os }}-node-${{ inputs.node-version }}-

      - name: Install dependencies
        working-directory: ${{ inputs.working-directory }}
        run: |
          echo "Installing dependencies for ${{ inputs.component }}..."
          npm ci

      - name: Build application
        working-directory: ${{ inputs.working-directory }}
        run: |
          echo "Building ${{ inputs.component }}..."

          # Set environment variables for build
          export NODE_ENV=${{ inputs.environment }}
          export ENVIRONMENT=${{ inputs.environment }}

          # For backend, we skip the build command since we want source-based artifacts
          # The deployment action will handle the packaging
          if [ "${{ inputs.component }}" = "backend" ]; then
            echo "âœ… Backend build skipped - will create source-based artifact"
          else
            # Run build command for other components
            if npm run ${{ inputs.build-command }} 2>/dev/null; then
              echo "âœ… Build completed successfully"
            else
              echo "âŒ Build failed"
              exit 1
            fi
          fi

      - name: Create build artefact
        id: build-artefact
        run: |
          echo "Creating build artefact for ${{ inputs.component }}..."

          # Determine artefact name
          if [ -n "${{ inputs.artefact-name }}" ]; then
            artefact_name="${{ inputs.artefact-name }}"
          else
            artefact_name="${{ inputs.component }}-build-$(date +%s)"
          fi

          # Ensure dist directory exists at workspace root
          mkdir -p dist

          # Create artefact based on component type
          if [ "${{ inputs.component }}" = "frontend" ]; then
            # Frontend: Package source files for the new Manifest Pointer architecture
            cd ${{ inputs.working-directory }}
            tar -czf "../dist/$artefact_name.tar.gz" \
              --exclude="node_modules" \
              --exclude="__tests__" \
              --exclude="coverage" \
              --exclude="*.test.js" \
              --exclude=".prettierrc" \
              --exclude="eslint.config.js" \
              --exclude="package.json" \
              --exclude="package-lock.json" \
              --exclude="test-manifest-pointer.html" \
              --exclude="debug.html" \
              .
            
            echo "artefact-name=$artefact_name.tar.gz" >> $GITHUB_OUTPUT
            echo "artefact-path=dist/$artefact_name.tar.gz" >> $GITHUB_OUTPUT
            echo "âœ… Frontend artefact created: dist/$artefact_name.tar.gz"
          else
            # Backend: Create Lambda-ready ZIP artifact directly
            cd ${{ inputs.working-directory }}
            
            # Create score_api.zip directly - this is what Lambda expects
            zip -r "../dist/score_api.zip" \
              --exclude="__tests__/*" \
              --exclude="coverage/*" \
              --exclude=".nyc_output/*" \
              --exclude=".eslintrc*" \
              --exclude=".prettierrc*" \
              --exclude="jest.config.js" \
              --exclude=".git/*" \
              --exclude=".github/*" \
              --exclude=".env*" \
              .
            
            # The artifact name for GitHub Actions is still the parameter
            echo "artefact-name=$artefact_name" >> $GITHUB_OUTPUT
            echo "artefact-path=dist/score_api.zip" >> $GITHUB_OUTPUT
            echo "âœ… Backend Lambda artifact created: dist/score_api.zip"
          fi

      - name: Generate build checksum
        run: |
          artefact_path="${{ steps.build-artefact.outputs.artefact-path }}"
          if [ -f "$artefact_path" ]; then
            sha256sum "$artefact_path" > "$artefact_path.sha256"
            echo "âœ… Checksum generated for $artefact_path"
          else
            echo "âŒ Artefact not found at $artefact_path"
            exit 1
          fi

      - name: Upload build artefact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.build-artefact.outputs.artefact-name }}
          path: |
            ${{ steps.build-artefact.outputs.artefact-path }}
            ${{ steps.build-artefact.outputs.artefact-path }}.sha256
          retention-days: 30

      - name: Generate build summary
        run: |
          echo "## ðŸ”¨ Build Summary for ${{ inputs.component }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âœ… **Dependencies**: Installed" >> $GITHUB_STEP_SUMMARY
          echo "âœ… **Build**: Completed" >> $GITHUB_STEP_SUMMARY
          echo "âœ… **Artefact**: Created" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Component**: ${{ inputs.component }}" >> $GITHUB_STEP_SUMMARY
          echo "**Working Directory**: \`${{ inputs.working-directory }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Build Command**: \`npm run ${{ inputs.build-command }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Environment**: \`${{ inputs.environment }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Node Version**: \`${{ inputs.node-version }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Artefact Name**: \`${{ steps.build-artefact.outputs.artefact-name }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Artefact Path**: \`${{ steps.build-artefact.outputs.artefact-path }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Artefact Checksum**: \`${{ steps.build-artefact.outputs.artefact-path }}.sha256\`" >> $GITHUB_STEP_SUMMARY
          echo "**Artefact Size**: \`$(du -sh ${{ steps.build-artefact.outputs.artefact-path }})\`" >> $GITHUB_STEP_SUMMARY
          echo "**Artefact Type**: \`$(file ${{ steps.build-artefact.outputs.artefact-path }})\`" >> $GITHUB_STEP_SUMMARY
