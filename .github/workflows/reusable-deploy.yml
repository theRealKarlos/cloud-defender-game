name: Reusable Deploy

on:
  workflow_call:
    inputs:
      environment:
        description: "Environment to deploy to (development, production)"
        required: true
        type: string
      aws-region:
        description: "AWS region for deployment"
        required: true
        type: string
      terraform-version:
        description: "Terraform version to use"
        required: true
        type: string
      working-directory:
        description: "Working directory for Terraform"
        required: false
        type: string
        default: "infra"
      frontend-artefact:
        description: "Frontend build artefact name"
        required: false
        type: string
        default: ""
      backend-artefact:
        description: "Backend build artefact name"
        required: false
        type: string
        default: ""
    secrets:
      AWS_ROLE_TO_ASSUME:
        description: "The ARN of the AWS IAM role to assume."
        required: true
    outputs:
      deployment-url:
        description: "URL of the deployed application"
        value: ${{ jobs.deploy.outputs.deployment-url }}
      function-url:
        description: "Lambda function URL"
        value: ${{ jobs.deploy.outputs.function-url }}

jobs:
  validate-infrastructure:
    name: Validate Infrastructure
    runs-on: ubuntu-latest
    timeout-minutes: 15
    defaults:
      run:
        working-directory: ${{ inputs.working-directory }}

    steps:
      # =================================================================
      # âš™ï¸ TERRAFORM SETUP
      # =================================================================
      # The following Terraform setup steps (checkout, setup terraform, cache)
      # are intentionally duplicated in validate-infrastructure, security-scan,
      # and plan-and-cost jobs.
      #
      # WHY: GitHub Actions does not permit calling a reusable workflow
      # from within a step. Common setup logic must therefore be
      # defined explicitly within each job that needs it, rather than
      # being abstracted into a separate, nested reusable workflow.
      # =================================================================
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ inputs.terraform-version }}
          terraform_wrapper: false

      # =================================================================
      # ðŸ”„ TERRAFORM SHARED PLUGIN CACHE (INDUSTRY STANDARD)
      # =================================================================
      # This implements the official HashiCorp-recommended approach for
      # speeding up terraform init in CI/CD pipelines.
      #
      # PROBLEM SOLVED: Caching the project's .terraform directory directly
      # causes "file exists" errors because terraform init expects exclusive
      # control over its working directory.
      #
      # SOLUTION: Use a shared plugin cache directory with TF_PLUGIN_CACHE_DIR.
      # This allows terraform init to create symbolic links to cached plugins,
      # avoiding conflicts while maintaining speed.
      #
      # HOW IT WORKS:
      # 1. Create a shared cache directory at workspace root
      # 2. Set TF_PLUGIN_CACHE_DIR environment variable
      # 3. Cache the shared directory between jobs
      # 4. terraform init creates symlinks to cached plugins
      # =================================================================
      - name: Setup Terraform Plugin Cache
        run: |
          mkdir -p ${{ github.workspace }}/.tf-cache
          echo "TF_PLUGIN_CACHE_DIR=${{ github.workspace }}/.tf-cache" >> $GITHUB_ENV

      - name: Cache Terraform Plugin Cache
        uses: actions/cache@v4
        with:
          path: ${{ github.workspace }}/.tf-cache
          key: ${{ runner.os }}-terraform-plugins-${{ inputs.terraform-version }}-${{ hashFiles(format('{0}/.terraform.lock.hcl', inputs.working-directory)) }}-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-terraform-plugins-${{ inputs.terraform-version }}-${{ hashFiles(format('{0}/.terraform.lock.hcl', inputs.working-directory)) }}-
            ${{ runner.os }}-terraform-plugins-${{ inputs.terraform-version }}-

      - name: Terraform Init
        working-directory: ${{ inputs.working-directory }}
        run: |
          echo "Initialising Terraform..."
          terraform init -backend=false -input=false
          echo "âœ… Terraform initialisation without backend completed"

      # =================================================================
      # ðŸŽ­ DUMMY ARTIFACT CREATION
      # =================================================================
      # This step creates a temporary, empty placeholder file that satisfies
      # Terraform''s filebase64sha256() function calls during validation.
      #
      # WHY: The validate-infrastructure job runs before the real artifacts
      # are downloaded. Terraform validation needs the file to exist for
      # syntax checking, but doesn''t need the actual content at this stage.
      #
      # INDUSTRY STANDARD: This is the recommended approach for CI/CD
      # pipelines where infrastructure validation runs in parallel with or
      # before artifact downloads. It keeps validation fast and decouples
      # infrastructure syntax checks from application build artifacts.
      #
      # ALTERNATIVES CONSIDERED:
      # - Download artifacts in validation job: Slower, couples concerns
      # - Skip validation: Reduces safety, not recommended
      # - Modify Terraform: Breaks local development workflow
      # =================================================================
      - name: Create dummy artifact for validation
        run: |
          echo "Creating dummy artifact for Terraform validation..."
          mkdir -p ../dist
          touch ../dist/score_api.zip
          echo "âœ… Dummy artifact created: ../dist/score_api.zip"

      - name: Terraform Format Check
        run: |
          echo "Checking Terraform formatting..."
          if ! terraform fmt -check -recursive -diff; then
            echo "âŒ Terraform formatting check failed"
            echo "Run 'terraform fmt -recursive' to fix formatting issues"
            exit 1
          else
            echo "âœ… Terraform formatting is correct"
          fi

      - name: Terraform Validate
        run: |
          echo "Validating Terraform configuration..."
          if terraform validate -json > validation-results.json; then
            echo "âœ… Terraform validation passed"
            cat validation-results.json | jq -r '.diagnostics[]? | "[\(.severity | ascii_upcase)] \(.summary): \(.detail)"' || true
          else
            echo "âŒ Terraform validation failed"
            cat validation-results.json | jq -r '.diagnostics[]? | "[\(.severity | ascii_upcase)] \(.summary): \(.detail)"'
            exit 1
          fi

      - name: Upload validation results
        uses: actions/upload-artifact@v4
        with:
          name: terraform-validation-results
          path: ${{ inputs.working-directory }}/validation-results.json
          retention-days: 30

  security-scan:
    name: Infrastructure Security Scan
    runs-on: ubuntu-latest
    timeout-minutes: 10
    defaults:
      run:
        working-directory: ${{ inputs.working-directory }}

    steps:
      # =================================================================
      # âš™ï¸ TERRAFORM SETUP
      # =================================================================
      # The following Terraform setup steps (checkout, setup terraform, cache)
      # are intentionally duplicated in validate-infrastructure, security-scan,
      # and plan-and-cost jobs.
      #
      # WHY: GitHub Actions does not permit calling a reusable workflow
      # from within a step. Common setup logic must therefore be
      # defined explicitly within each job that needs it, rather than
      # being abstracted into a separate, nested reusable workflow.
      # =================================================================
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ inputs.terraform-version }}
          terraform_wrapper: false

      # =================================================================
      # ðŸ”„ TERRAFORM SHARED PLUGIN CACHE (INDUSTRY STANDARD)
      # =================================================================
      # This implements the official HashiCorp-recommended approach for
      # speeding up terraform init in CI/CD pipelines.
      #
      # PROBLEM SOLVED: Caching the project's .terraform directory directly
      # causes "file exists" errors because terraform init expects exclusive
      # control over its working directory.
      #
      # SOLUTION: Use a shared plugin cache directory with TF_PLUGIN_CACHE_DIR.
      # This allows terraform init to create symbolic links to cached plugins,
      # avoiding conflicts while maintaining speed.
      #
      # HOW IT WORKS:
      # 1. Create a shared cache directory at workspace root
      # 2. Set TF_PLUGIN_CACHE_DIR environment variable
      # 3. Cache the shared directory between jobs
      # 4. terraform init creates symlinks to cached plugins
      # =================================================================
      - name: Setup Terraform Plugin Cache
        run: |
          mkdir -p ${{ github.workspace }}/.tf-cache
          echo "TF_PLUGIN_CACHE_DIR=${{ github.workspace }}/.tf-cache" >> $GITHUB_ENV

      - name: Cache Terraform Plugin Cache
        uses: actions/cache@v4
        with:
          path: ${{ github.workspace }}/.tf-cache
          key: ${{ runner.os }}-terraform-plugins-${{ inputs.terraform-version }}-${{ hashFiles(format('{0}/.terraform.lock.hcl', inputs.working-directory)) }}-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-terraform-plugins-${{ inputs.terraform-version }}-${{ hashFiles(format('{0}/.terraform.lock.hcl', inputs.working-directory)) }}-
            ${{ runner.os }}-terraform-plugins-${{ inputs.terraform-version }}-

      - name: Terraform Init
        working-directory: ${{ inputs.working-directory }}
        run: |
          echo "Initialising Terraform..."
          terraform init -backend=false -input=false
          echo "âœ… Terraform initialisation without backend completed"

      - name: Run tfsec security scan
        uses: aquasecurity/tfsec-action@v1.0.0
        with:
          working_directory: ${{ inputs.working-directory }}
          format: json
          soft_fail: true

      - name: Setup Python for Checkov
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install Checkov
        run: |
          pip install checkov

      - name: Run Checkov compliance scan
        run: |
          echo "Running Checkov compliance scan..."
          checkov -d . --framework terraform --output json --output-file checkov-results.json --soft-fail

      - name: Upload security scan results
        uses: actions/upload-artifact@v4
        with:
          name: infrastructure-security-reports
          path: |
            ${{ inputs.working-directory }}/tfsec-results.json
            ${{ inputs.working-directory }}/checkov-results.json
          retention-days: 30

  plan-and-cost:
    name: Terraform Plan & Cost Analysis
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: [validate-infrastructure, security-scan]
    defaults:
      run:
        working-directory: ${{ inputs.working-directory }}

    # OIDC permissions for AWS authentication
    permissions:
      id-token: write
      contents: read
      pull-requests: write

    steps:
      # =================================================================
      # âš™ï¸ TERRAFORM SETUP
      # =================================================================
      # The following Terraform setup steps (checkout, setup terraform, cache)
      # are intentionally duplicated in validate-infrastructure, security-scan,
      # and plan-and-cost jobs.
      #
      # WHY: GitHub Actions does not permit calling a reusable workflow
      # from within a step. Common setup logic must therefore be
      # defined explicitly within each job that needs it, rather than
      # being abstracted into a separate, nested reusable workflow.
      # =================================================================
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ inputs.terraform-version }}
          terraform_wrapper: false

      - name: Configure Terraform plugin cache
        run: |
          mkdir -p ~/.terraform.d/plugin-cache
          echo 'plugin_cache_dir = "$HOME/.terraform.d/plugin-cache"' > ~/.terraformrc

      # =================================================================
      # ðŸ”„ TERRAFORM SHARED PLUGIN CACHE (INDUSTRY STANDARD)
      # =================================================================
      # This implements the official HashiCorp-recommended approach for
      # speeding up terraform init in CI/CD pipelines.
      #
      # PROBLEM SOLVED: Caching the project's .terraform directory directly
      # causes "file exists" errors because terraform init expects exclusive
      # control over its working directory.
      #
      # SOLUTION: Use a shared plugin cache directory with TF_PLUGIN_CACHE_DIR.
      # This allows terraform init to create symbolic links to cached plugins,
      # avoiding conflicts while maintaining speed.
      #
      # HOW IT WORKS:
      # 1. Create a shared cache directory at workspace root
      # 2. Set TF_PLUGIN_CACHE_DIR environment variable
      # 3. Cache the shared directory between jobs
      # 4. terraform init creates symlinks to cached plugins
      # =================================================================
      - name: Setup Terraform Plugin Cache
        run: |
          mkdir -p ${{ github.workspace }}/.tf-cache
          echo "TF_PLUGIN_CACHE_DIR=${{ github.workspace }}/.tf-cache" >> $GITHUB_ENV

      - name: Cache Terraform Plugin Cache
        uses: actions/cache@v4
        with:
          path: ${{ github.workspace }}/.tf-cache
          key: ${{ runner.os }}-terraform-plugins-${{ inputs.terraform-version }}-${{ hashFiles(format('{0}/.terraform.lock.hcl', inputs.working-directory)) }}-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-terraform-plugins-${{ inputs.terraform-version }}-${{ hashFiles(format('{0}/.terraform.lock.hcl', inputs.working-directory)) }}-
            ${{ runner.os }}-terraform-plugins-${{ inputs.terraform-version }}-

      - name: Configure AWS credentials using OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          role-session-name: GitHubActions-TerraformPlan
          aws-region: ${{ inputs.aws-region }}
          mask-aws-account-id: false

      # =================================================================
      # ðŸ“¦ REAL ARTIFACT DOWNLOAD FOR PLANNING
      # =================================================================
      # This step downloads the real backend artifact and stages it for
      # Terraform planning. This ensures the plan is generated with the
      # correct code hash, eliminating the "inconsistent final plan" error.
      #
      # WHY: The plan-and-cost job now runs after the backend build job
      # completes, allowing us to use the real artifact instead of a dummy.
      # This creates a more accurate plan and cost estimate.
      # =================================================================
      - name: Download backend artifact for planning
        if: inputs.backend-artefact != ''
        uses: actions/download-artifact@v4
        with:
          name: ${{ inputs.backend-artefact }}
          path: ../dist/
        continue-on-error: true

      # =================================================================
      # ðŸ”§ TERRAFORM INITIALIZATION (MANDATORY STEP)
      # =================================================================
      # Terraform `init` is always required before `plan`. It configures
      # the backend and makes Terraform "aware" of the provider plugins.
      # Crucially, this is the step that leverages the cache. If the cache
      # was restored successfully, this init will be almost instantaneous
      # as the plugins are already on disk. If the cache was missed, this
      # step will download the providers, ensuring the pipeline succeeds.
      # =================================================================
      - name: Terraform Init
        working-directory: ${{ inputs.working-directory }}
        run: |
          echo "Initialising Terraform for environment: ${{ inputs.environment }}..."
          terraform init -input=false -backend-config="key=cloud-defenders/envs/${{ inputs.environment }}/terraform.tfstate"
          echo "âœ… Terraform initialisation with backend completed"

      - name: Generate Terraform plan
        id: plan
        run: |
          echo "Creating Terraform plan..."
          echo "Current working directory: $(pwd)"
          echo "Plan will be saved to: $(pwd)/tfplan"

          set +e  # Disable immediate exit on error
          terraform plan \
            -input=false \
            -out=tfplan \
            -detailed-exitcode \
            -var="environment=${{ inputs.environment }}" \
            -no-color > plan-output.txt 2>&1

          PLAN_EXIT_CODE=$?
          set -e  # Re-enable immediate exit on error

          echo "Plan file created at: $(pwd)/tfplan"
          echo "Plan file exists: $(test -f tfplan && echo 'YES' || echo 'NO')"
          echo "Plan file size: $(ls -la tfplan 2>/dev/null || echo 'File not found')"

          echo "Lock file created at: $(pwd)/.terraform.lock.hcl"
          echo "Lock file exists: $(test -f .terraform.lock.hcl && echo 'YES' || echo 'NO')"
          echo "Lock file size: $(ls -la .terraform.lock.hcl 2>/dev/null || echo 'File not found')"

          if [ $PLAN_EXIT_CODE -eq 0 ]; then
            echo "âœ… No changes detected in Terraform plan"
            echo "plan_status=no-changes" >> $GITHUB_OUTPUT
          elif [ $PLAN_EXIT_CODE -eq 2 ]; then
            echo "âœ… Terraform plan completed with changes"
            echo "plan_status=changes" >> $GITHUB_OUTPUT
          else
            echo "âŒ Terraform plan failed"
            echo "plan_status=failed" >> $GITHUB_OUTPUT
            echo "Error details:"
            cat plan-output.txt
            exit 1
          fi

      - name: Stage Deployment Artifacts
        if: steps.plan.outputs.plan_status != 'failed'
        run: |
          set -e
          echo "=== STAGING DEBUG INFO ==="
          echo "Current working directory: $(pwd)"
          echo "Repository root: ${{ github.workspace }}"
          echo "Staging directory will be: ${{ github.workspace }}/tf-artifacts"

          echo "Creating staging directory for artifacts..."
          mkdir -p ${{ github.workspace }}/tf-artifacts

          echo "---"
          echo "Source files check:"
          echo "tfplan exists: $(test -f tfplan && echo 'YES' || echo 'NO')"
          echo "tfplan size: $(ls -la tfplan 2>/dev/null || echo 'File not found')"
          echo ".terraform.lock.hcl exists: $(test -f .terraform.lock.hcl && echo 'YES' || echo 'NO')"
          echo ".terraform.lock.hcl size: $(ls -la .terraform.lock.hcl 2>/dev/null || echo 'File not found')"

          echo "---"
          echo "Copying required files to staging directory..."
          cp tfplan ${{ github.workspace }}/tf-artifacts/
          cp .terraform.lock.hcl ${{ github.workspace }}/tf-artifacts/

          echo "---"
          echo "Verifying contents of staging directory:"
          ls -la ${{ github.workspace }}/tf-artifacts/

          echo "---"
          echo "Final verification:"
          if [ ! -f "${{ github.workspace }}/tf-artifacts/tfplan" ]; then
            echo "âŒ ERROR: tfplan file not found in staging directory"
            exit 1
          fi
          if [ ! -f "${{ github.workspace }}/tf-artifacts/.terraform.lock.hcl" ]; then
            echo "âŒ ERROR: .terraform.lock.hcl file not found in staging directory"
            exit 1
          fi
          echo "âœ… Both required files successfully copied to staging directory"

      - name: Debug File Locations After Plan
        if: always()
        run: |
          echo "--- Debugging file locations ---"
          echo "Listing all files recursively from the workspace root..."
          ls -R ${{ github.workspace }}
          echo "--- End of recursive list ---"

      - name: Generate cost estimate with Infracost
        uses: infracost/actions/comment@v1
        if: steps.plan.outputs.plan_status == 'changes'
        with:
          path: ${{ inputs.working-directory }}/tfplan
          behavior: new
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload Terraform plan artefacts
        if: steps.plan.outputs.plan_status != 'failed'
        uses: actions/upload-artifact@v4
        with:
          name: terraform-plan-artefacts
          path: ${{ github.workspace }}/tf-artifacts
          include-hidden-files: true
          retention-days: 30
          if-no-files-found: error

  deploy:
    name: Deploy Infrastructure & Applications
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: [plan-and-cost]
    if: success()
    environment:
      name: ${{ inputs.environment }}
      url: ${{ steps.deploy-frontend.outputs.deployment-url }}

    # OIDC permissions for AWS authentication
    permissions:
      id-token: write
      contents: read

    outputs:
      deployment-url: ${{ steps.deploy-frontend.outputs.deployment-url }}
      function-url: ${{ steps.deploy-backend.outputs.function-url }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Configure AWS credentials using OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          role-session-name: GitHubActions-Deploy
          aws-region: ${{ inputs.aws-region }}
          mask-aws-account-id: false

      - name: Download frontend artifact
        if: inputs.frontend-artefact != ''
        uses: actions/download-artifact@v4
        with:
          name: ${{ inputs.frontend-artefact }}
          path: ./frontend-artefact
        continue-on-error: true

      - name: Download backend artifact
        if: inputs.backend-artefact != ''
        uses: actions/download-artifact@v4
        with:
          name: ${{ inputs.backend-artefact }}
          path: ./dist/
        continue-on-error: true

      - name: Download Terraform plan
        uses: actions/download-artifact@v4
        with:
          name: terraform-plan-artefacts
          path: ${{ inputs.working-directory }}

      - name: Setup Terraform for infrastructure deployment
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ inputs.terraform-version }}
          terraform_wrapper: false

      # =================================================================
      # ðŸ”„ TERRAFORM SHARED PLUGIN CACHE (INDUSTRY STANDARD)
      # =================================================================
      # This implements the official HashiCorp-recommended approach for
      # speeding up terraform init in CI/CD pipelines.
      #
      # PROBLEM SOLVED: Caching the project's .terraform directory directly
      # causes "file exists" errors because terraform init expects exclusive
      # control over its working directory.
      #
      # SOLUTION: Use a shared plugin cache directory with TF_PLUGIN_CACHE_DIR.
      # This allows terraform init to create symbolic links to cached plugins,
      # avoiding conflicts while maintaining speed.
      #
      # HOW IT WORKS:
      # 1. Create a shared cache directory at workspace root
      # 2. Set TF_PLUGIN_CACHE_DIR environment variable
      # 3. Cache the shared directory between jobs
      # 4. terraform init creates symlinks to cached plugins
      # =================================================================
      - name: Setup Terraform Plugin Cache
        run: |
          mkdir -p ${{ github.workspace }}/.tf-cache
          echo "TF_PLUGIN_CACHE_DIR=${{ github.workspace }}/.tf-cache" >> $GITHUB_ENV

      - name: Restore Terraform Plugin Cache
        uses: actions/cache@v4
        with:
          path: ${{ github.workspace }}/.tf-cache
          key: ${{ runner.os }}-terraform-plugins-${{ inputs.terraform-version }}-${{ hashFiles(format('{0}/.terraform.lock.hcl', inputs.working-directory)) }}-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-terraform-plugins-${{ inputs.terraform-version }}-${{ hashFiles(format('{0}/.terraform.lock.hcl', inputs.working-directory)) }}-
            ${{ runner.os }}-terraform-plugins-${{ inputs.terraform-version }}-

      # =================================================================
      # ðŸ”§ TERRAFORM INITIALIZATION (MANDATORY STEP)
      # =================================================================
      # Terraform `init` is always required before `apply`. It configures
      # the backend and makes Terraform "aware" of the provider plugins.
      # Crucially, this is the step that leverages the cache. If the cache
      # was restored successfully, this init will be almost instantaneous
      # as the plugins are already on disk. If the cache was missed, this
      # step will download the providers, ensuring the pipeline succeeds.
      # =================================================================
      - name: Initialize Terraform for deployment
        working-directory: ${{ inputs.working-directory }}
        run: |
          echo "Initialising Terraform for environment: ${{ inputs.environment }}..."
          terraform init \
            -input=false \
            -backend-config="key=cloud-defenders/envs/${{ inputs.environment }}/terraform.tfstate"

      - name: Debug After Cache Restore
        if: always()
        run: |
          echo "--- Verifying infra directory before apply ---"
          ls -la ${{ inputs.working-directory }}
          echo "--- Verifying .terraform directory structure before apply ---"
          ls -R ${{ inputs.working-directory }}/.terraform
          echo "--- End of debug ---"

      # =================================================================
      # ðŸ”§ DEPLOYMENT EXECUTION
      # =================================================================
      # The deployment job now has guaranteed provider availability through
      # the terraform init step above. This ensures the apply step will
      # succeed regardless of cache state, while maintaining optimal speed
      # when the cache is successfully restored.
      # =================================================================

      - name: Apply Terraform infrastructure changes
        working-directory: ${{ inputs.working-directory }}
        run: |
          echo "Applying Terraform infrastructure changes for ${{ inputs.environment }}..."
          if terraform apply -input=false tfplan; then
            echo "âœ… Infrastructure deployment completed successfully"
          else
            echo "âŒ Infrastructure deployment failed"
            exit 1
          fi

      - name: Get infrastructure outputs
        id: terraform-outputs
        working-directory: ${{ inputs.working-directory }}
        run: |
          # Get key infrastructure outputs for deployment
          s3_bucket=$(terraform output -raw s3_bucket_name 2>/dev/null || echo "")
          cloudfront_id=$(terraform output -raw cloudfront_distribution_id 2>/dev/null || echo "")
          lambda_function=$(terraform output -raw lambda_function_name 2>/dev/null || echo "")

          echo "s3_bucket=$s3_bucket" >> $GITHUB_OUTPUT
          echo "cloudfront_id=$cloudfront_id" >> $GITHUB_OUTPUT
          echo "lambda_function=$lambda_function" >> $GITHUB_OUTPUT

          echo "Infrastructure outputs retrieved:"
          echo "- S3 Bucket: $s3_bucket"
          echo "- CloudFront Distribution: $cloudfront_id"
          echo "- Lambda Function: $lambda_function"

      - name: Extract frontend artefacts
        if: inputs.frontend-artefact != ''
        run: |
          echo "Extracting frontend artifacts..."
          # The deployment action expects the files to be in ./frontend/dist.
          # We must create this directory first to ensure it exists. This is
          # a robust way to handle archives that may not contain the root folder.
          mkdir -p ./frontend/dist

          # Debug: Show what's in the artifact directory.
          echo "Contents of frontend-artefact directory:"
          ls -la ./frontend-artefact

          # The artifact is a .tar.gz file. We extract its contents directly
          # into the prepared ./frontend/dist directory.
          tar -xzf ./frontend-artefact/*.tar.gz -C ./frontend/dist/

          echo "âœ… Frontend artifacts extracted."

          # Debug: Verify the files are in the correct location.
          echo "Contents of ./frontend/dist after extraction:"
          ls -la ./frontend/dist

      - name: Deploy frontend
        id: deploy-frontend
        if: inputs.frontend-artefact != ''
        uses: ./.github/actions/deploy-frontend
        with:
          aws-region: ${{ inputs.aws-region }}
          s3-bucket: ${{ steps.terraform-outputs.outputs.s3_bucket }}
          cloudfront-distribution-id: ${{ steps.terraform-outputs.outputs.cloudfront_id }}
          environment: ${{ inputs.environment }}
          build-directory: ./frontend/dist
          source-directory: ./frontend

      - name: Extract backend source for deployment
        if: inputs.backend-artefact != ''
        run: |
          echo "Extracting backend source for deployment..."
          # Extract the backend source from the tar.gz artifact
          tar -xzf ./backend-artefact/backend-build.tar.gz -C ./backend-artefact/
          echo "âœ… Backend source extracted for deployment"

      - name: Deploy backend
        id: deploy-backend
        if: inputs.backend-artefact != ''
        uses: ./.github/actions/deploy-backend
        with:
          aws-region: ${{ inputs.aws-region }}
          function-name: ${{ steps.terraform-outputs.outputs.lambda_function }}
          environment: ${{ inputs.environment }}
          source-directory: ./backend-artefact
          environment-variables: |
            {
              "NODE_ENV": "${{ inputs.environment }}",
              "ENVIRONMENT": "${{ inputs.environment }}",
              "LOG_LEVEL": "${{ inputs.environment == 'production' && 'info' || 'debug' }}"
            }

      - name: Run post-deployment health checks
        run: |
          echo "Running post-deployment health checks for ${{ inputs.environment }} environment..."

          # Use the dedicated health check script
          bash scripts/health-check.sh \
            --frontend-url "${{ steps.deploy-frontend.outputs.deployment-url }}" \
            --backend-url "${{ steps.deploy-backend.outputs.function-url }}" \
            --timeout 30

      - name: Generate deployment summary
        run: |
          echo "## ðŸš€ Deployment Summary for ${{ inputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** ${{ inputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "**Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "### Infrastructure Deployment" >> $GITHUB_STEP_SUMMARY
          echo "âœ… **Terraform Apply:** Completed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ inputs.frontend-artefact }}" != "" ]; then
            echo "### Frontend Deployment" >> $GITHUB_STEP_SUMMARY
            if [ "${{ steps.deploy-frontend.outcome }}" == "success" ]; then
              echo "âœ… **Status:** Successful" >> $GITHUB_STEP_SUMMARY
              echo "ðŸ”— **URL:** ${{ steps.deploy-frontend.outputs.deployment-url }}" >> $GITHUB_STEP_SUMMARY
            else
              echo "âŒ **Status:** Failed" >> $GITHUB_STEP_SUMMARY
            fi
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          if [ "${{ inputs.backend-artefact }}" != "" ]; then
            echo "### Backend Deployment" >> $GITHUB_STEP_SUMMARY
            if [ "${{ steps.deploy-backend.outcome }}" == "success" ]; then
              echo "âœ… **Status:** Successful" >> $GITHUB_STEP_SUMMARY
              echo "ðŸ”— **Function ARN:** ${{ steps.deploy-backend.outputs.function-arn }}" >> $GITHUB_STEP_SUMMARY
              if [ -n "${{ steps.deploy-backend.outputs.function-url }}" ]; then
                echo "ðŸ”— **Function URL:** ${{ steps.deploy-backend.outputs.function-url }}" >> $GITHUB_STEP_SUMMARY
              fi
            else
              echo "âŒ **Status:** Failed" >> $GITHUB_STEP_SUMMARY
            fi
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          echo "Deployment completed successfully! ðŸŽ‰" >> $GITHUB_STEP_SUMMARY
